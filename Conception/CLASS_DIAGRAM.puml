@startuml SimStruct Class Diagram

!define ENTITY_COLOR #E8F5E9
!define DTO_COLOR #E3F2FD
!define SERVICE_COLOR #FFF3E0
!define REPOSITORY_COLOR #F3E5F5
!define CONTROLLER_COLOR #FFEBEE
!define ENUM_COLOR #F5F5F5

skinparam class {
    BackgroundColor<<Entity>> ENTITY_COLOR
    BackgroundColor<<DTO>> DTO_COLOR
    BackgroundColor<<Service>> SERVICE_COLOR
    BackgroundColor<<Repository>> REPOSITORY_COLOR
    BackgroundColor<<Controller>> CONTROLLER_COLOR
    BackgroundColor<<Enum>> ENUM_COLOR
}

' ==================== ENUMS ====================

enum UserRole <<Enum>> {
    USER
    PRO
    ADMIN
}

enum MaterialType <<Enum>> {
    CONCRETE
    STEEL
    WOOD
    ALUMINUM
    COMPOSITE
}

enum LoadType <<Enum>> {
    POINT
    DISTRIBUTED
    MOMENT
    TRIANGULAR
    TRAPEZOIDAL
    UNIFORM
}

enum SupportType <<Enum>> {
    SIMPLY_SUPPORTED
    FIXED_FIXED
    FIXED_FREE
    FIXED_PINNED
    CONTINUOUS
    FIXED
    PINNED
}

enum SimulationStatus <<Enum>> {
    DRAFT
    RUNNING
    COMPLETED
    FAILED
}

enum FriendshipStatus <<Enum>> {
    PENDING
    ACCEPTED
    BLOCKED
}

enum InvitationStatus <<Enum>> {
    PENDING
    ACCEPTED
    DECLINED
    EXPIRED
}

enum SharePermission <<Enum>> {
    VIEW
    COMMENT
    EDIT
}

enum NotificationType <<Enum>> {
    INFO
    SUCCESS
    WARNING
    ERROR
}

enum NotificationCategory <<Enum>> {
    SIMULATION
    COMMUNITY
    SYSTEM
    MARKETING
}

' ==================== ENTITIES ====================

abstract class BaseEntity <<Entity>> {
    - id: UUID
    - createdAt: LocalDateTime
    - updatedAt: LocalDateTime
}

abstract class SoftDeletableEntity <<Entity>> {
    - deletedAt: LocalDateTime
}

class User <<Entity>> {
    - id: UUID
    - email: String {unique}
    - password: String
    - name: String
    - role: UserRole
    - emailVerified: Boolean
    - avatarUrl: String
    - phone: String
    - company: String
    - jobTitle: String
    - bio: String
    - createdAt: LocalDateTime
    - updatedAt: LocalDateTime
    - deletedAt: LocalDateTime
    --
    + getInitials(): String
    + getFirstName(): String
}

class Simulation <<Entity>> {
    - id: UUID
    - userId: UUID
    - name: String
    - description: String
    - beamLength: Double
    - beamHeight: Double
    - beamWidth: Double
    - materialType: MaterialType
    - elasticModulus: Double
    - loadType: LoadType
    - loadMagnitude: Double
    - loadPosition: Double
    - supportType: SupportType
    - isPublic: Boolean
    - isFavorite: Boolean
    - status: SimulationStatus
    - createdAt: LocalDateTime
    - updatedAt: LocalDateTime
    - deletedAt: LocalDateTime
    --
    + isOwner(userId: UUID): Boolean
}

class SimulationResult <<Entity>> {
    - id: UUID
    - simulationId: UUID {unique}
    - maxDeflection: Double
    - maxBendingMoment: Double
    - maxShearForce: Double
    - maxStress: Double
    - safetyFactor: Double
    - recommendations: String {JSON}
    - stressDistribution: String {JSON}
    - deflectionCurve: String {JSON}
    - aiInsights: String {JSON}
    - createdAt: LocalDateTime
    --
    + getResultStatus(): ResultStatus
}

class Friendship <<Entity>> {
    - id: UUID
    - requesterId: UUID
    - addresseeId: UUID
    - status: FriendshipStatus
    - createdAt: LocalDateTime
    - updatedAt: LocalDateTime
    --
    + isAccepted(): Boolean
    + isPending(): Boolean
}

class Invitation <<Entity>> {
    - id: UUID
    - senderId: UUID
    - recipientEmail: String
    - message: String
    - status: InvitationStatus
    - expiresAt: LocalDateTime
    - createdAt: LocalDateTime
    - updatedAt: LocalDateTime
    --
    + isExpired(): Boolean
}

class SharedSimulation <<Entity>> {
    - id: UUID
    - simulationId: UUID
    - ownerId: UUID
    - sharedWithId: UUID
    - permission: SharePermission
    - message: String
    - createdAt: LocalDateTime
}

class Notification <<Entity>> {
    - id: UUID
    - userId: UUID
    - type: NotificationType
    - category: NotificationCategory
    - title: String
    - message: String
    - actionUrl: String
    - data: String {JSON}
    - isRead: Boolean
    - createdAt: LocalDateTime
}

class Conversation <<Entity>> {
    - id: UUID
    - participant1Id: UUID
    - participant2Id: UUID
    - lastMessageAt: LocalDateTime
    - createdAt: LocalDateTime
    --
    + getOtherParticipant(userId: UUID): UUID
}

class ChatMessage <<Entity>> {
    - id: UUID
    - conversationId: UUID
    - senderId: UUID
    - content: String
    - isRead: Boolean
    - createdAt: LocalDateTime
}

class RefreshToken <<Entity>> {
    - id: UUID
    - userId: UUID
    - token: String {hashed}
    - expiresAt: LocalDateTime
    - createdAt: LocalDateTime
    - revokedAt: LocalDateTime
    --
    + isValid(): Boolean
    + isExpired(): Boolean
}

' ==================== DTOs ====================

package "DTOs - Request" {
    
    class LoginRequest <<DTO>> {
        - email: String
        - password: String
    }
    
    class RegisterRequest <<DTO>> {
        - name: String
        - email: String
        - password: String
    }
    
    class RefreshTokenRequest <<DTO>> {
        - refreshToken: String
    }
    
    class ForgotPasswordRequest <<DTO>> {
        - email: String
    }
    
    class ResetPasswordRequest <<DTO>> {
        - token: String
        - newPassword: String
    }
    
    class UpdateUserRequest <<DTO>> {
        - name: String
        - phone: String
        - company: String
        - jobTitle: String
        - bio: String
    }
    
    class ChangePasswordRequest <<DTO>> {
        - currentPassword: String
        - newPassword: String
    }
    
    class CreateSimulationRequest <<DTO>> {
        - name: String
        - description: String
        - beamLength: Double
        - beamHeight: Double
        - beamWidth: Double
        - materialType: MaterialType
        - elasticModulus: Double
        - loadType: LoadType
        - loadMagnitude: Double
        - loadPosition: Double
        - supportType: SupportType
        - isPublic: Boolean
    }
    
    class UpdateSimulationRequest <<DTO>> {
        - name: String
        - description: String
        - isPublic: Boolean
    }
    
    class SendInvitationRequest <<DTO>> {
        - email: String
        - message: String
    }
    
    class ShareSimulationRequest <<DTO>> {
        - simulationId: UUID
        - sharedWithId: UUID
        - permission: SharePermission
        - message: String
    }
    
    class SendMessageRequest <<DTO>> {
        - content: String
    }
}

package "DTOs - Response" {
    
    class ApiResponse<T> <<DTO>> {
        - success: Boolean
        - data: T
        - error: ErrorDetails
    }
    
    class ErrorDetails <<DTO>> {
        - code: String
        - message: String
        - details: Map<String, String>
        - timestamp: LocalDateTime
        - path: String
    }
    
    class PageResponse<T> <<DTO>> {
        - content: List<T>
        - page: Integer
        - size: Integer
        - totalElements: Long
        - totalPages: Integer
        - last: Boolean
    }
    
    class AuthResponse <<DTO>> {
        - accessToken: String
        - refreshToken: String
        - tokenType: String
        - expiresIn: Long
        - user: UserResponse
    }
    
    class UserResponse <<DTO>> {
        - id: UUID
        - email: String
        - name: String
        - role: String
        - avatarUrl: String
        - phone: String
        - company: String
        - jobTitle: String
        - bio: String
        - emailVerified: Boolean
        - createdAt: LocalDateTime
    }
    
    class UserStatsResponse <<DTO>> {
        - totalSimulations: Integer
        - monthlySimulations: Integer
        - completedSimulations: Integer
        - sharedSimulations: Integer
        - storageUsed: Double
    }
    
    class SimulationResponse <<DTO>> {
        - id: UUID
        - name: String
        - description: String
        - beamLength: Double
        - beamHeight: Double
        - beamWidth: Double
        - materialType: String
        - elasticModulus: Double
        - loadType: String
        - loadMagnitude: Double
        - loadPosition: Double
        - supportType: String
        - isPublic: Boolean
        - isFavorite: Boolean
        - status: String
        - createdAt: LocalDateTime
        - updatedAt: LocalDateTime
        - results: SimulationResultResponse
    }
    
    class SimulationResultResponse <<DTO>> {
        - maxDeflection: Double
        - maxBendingMoment: Double
        - maxShearForce: Double
        - maxStress: Double
        - safetyFactor: Double
        - recommendations: List<String>
        - status: String
    }
    
    class FriendResponse <<DTO>> {
        - id: UUID
        - friendshipId: UUID
        - name: String
        - email: String
        - avatarUrl: String
        - company: String
        - status: String
        - isInitiator: Boolean
        - connectedAt: LocalDateTime
    }
    
    class InvitationResponse <<DTO>> {
        - id: UUID
        - senderName: String
        - senderEmail: String
        - recipientEmail: String
        - message: String
        - status: String
        - isExpired: Boolean
        - expiresAt: LocalDateTime
        - createdAt: LocalDateTime
    }
    
    class SharedSimulationResponse <<DTO>> {
        - id: UUID
        - simulationId: UUID
        - simulationName: String
        - simulationDescription: String
        - ownerName: String
        - ownerEmail: String
        - sharedWithName: String
        - sharedWithEmail: String
        - permission: String
        - message: String
        - sharedAt: LocalDateTime
    }
    
    class NotificationResponse <<DTO>> {
        - id: UUID
        - type: String
        - category: String
        - title: String
        - message: String
        - actionUrl: String
        - data: Map<String, Object>
        - isRead: Boolean
        - createdAt: LocalDateTime
    }
    
    class ConversationResponse <<DTO>> {
        - id: UUID
        - otherParticipant: ParticipantResponse
        - lastMessage: ChatMessageResponse
        - unreadCount: Integer
        - createdAt: LocalDateTime
        - lastMessageAt: LocalDateTime
    }
    
    class ParticipantResponse <<DTO>> {
        - id: UUID
        - name: String
        - avatarUrl: String
    }
    
    class ChatMessageResponse <<DTO>> {
        - id: UUID
        - senderId: UUID
        - senderName: String
        - content: String
        - sentAt: LocalDateTime
        - isRead: Boolean
    }
}

' ==================== REPOSITORIES ====================

interface UserRepository <<Repository>> {
    + findByEmail(email: String): Optional<User>
    + existsByEmail(email: String): Boolean
    + findByIdAndDeletedAtIsNull(id: UUID): Optional<User>
}

interface SimulationRepository <<Repository>> {
    + findByUserIdAndDeletedAtIsNull(userId: UUID, pageable: Pageable): Page<Simulation>
    + findByIsPublicTrueAndDeletedAtIsNull(pageable: Pageable): Page<Simulation>
    + findByUserIdAndIsFavoriteTrueAndDeletedAtIsNull(userId: UUID, pageable: Pageable): Page<Simulation>
    + countByUserIdAndDeletedAtIsNull(userId: UUID): Long
}

interface SimulationResultRepository <<Repository>> {
    + findBySimulationId(simulationId: UUID): Optional<SimulationResult>
}

interface FriendshipRepository <<Repository>> {
    + findAcceptedFriendships(userId: UUID): List<Friendship>
    + findPendingRequests(userId: UUID): List<Friendship>
    + findSentRequests(userId: UUID): List<Friendship>
    + findByRequesterIdAndAddresseeId(requesterId: UUID, addresseeId: UUID): Optional<Friendship>
}

interface InvitationRepository <<Repository>> {
    + findBySenderId(senderId: UUID): List<Invitation>
    + findByRecipientEmail(email: String): List<Invitation>
    + findByRecipientEmailAndStatus(email: String, status: InvitationStatus): List<Invitation>
}

interface SharedSimulationRepository <<Repository>> {
    + findBySharedWithId(userId: UUID, pageable: Pageable): Page<SharedSimulation>
    + findByOwnerId(userId: UUID): List<SharedSimulation>
    + existsBySimulationIdAndSharedWithId(simulationId: UUID, sharedWithId: UUID): Boolean
}

interface NotificationRepository <<Repository>> {
    + findByUserIdOrderByCreatedAtDesc(userId: UUID, pageable: Pageable): Page<Notification>
    + findByUserIdAndIsReadFalse(userId: UUID, pageable: Pageable): Page<Notification>
    + countByUserIdAndIsReadFalse(userId: UUID): Long
    + markAllAsRead(userId: UUID): Integer
}

interface ConversationRepository <<Repository>> {
    + findUserConversations(userId: UUID): List<Conversation>
    + findByParticipants(user1Id: UUID, user2Id: UUID): Optional<Conversation>
}

interface ChatMessageRepository <<Repository>> {
    + findByConversationIdOrderBySentAtDesc(conversationId: UUID, pageable: Pageable): Page<ChatMessage>
    + countByConversationIdAndIsReadFalseAndSenderIdNot(conversationId: UUID, userId: UUID): Long
    + markConversationAsRead(conversationId: UUID, userId: UUID): Integer
}

interface RefreshTokenRepository <<Repository>> {
    + findByToken(token: String): Optional<RefreshToken>
    + deleteByUserId(userId: UUID): void
    + deleteExpiredTokens(): Integer
}

' ==================== SERVICES ====================

class AuthService <<Service>> {
    - userRepository: UserRepository
    - refreshTokenRepository: RefreshTokenRepository
    - passwordEncoder: PasswordEncoder
    - jwtService: JwtService
    --
    + register(request: RegisterRequest): AuthResponse
    + login(request: LoginRequest): AuthResponse
    + refreshToken(request: RefreshTokenRequest): AuthResponse
    + logout(userId: UUID): void
    + forgotPassword(request: ForgotPasswordRequest): void
    + resetPassword(request: ResetPasswordRequest): void
}

class UserService <<Service>> {
    - userRepository: UserRepository
    - simulationRepository: SimulationRepository
    --
    + getCurrentUser(): UserResponse
    + updateUser(request: UpdateUserRequest): UserResponse
    + changePassword(request: ChangePasswordRequest): void
    + deleteUser(): void
    + getUserStats(): UserStatsResponse
}

class SimulationService <<Service>> {
    - simulationRepository: SimulationRepository
    - resultRepository: SimulationResultRepository
    - calculationService: CalculationService
    --
    + create(request: CreateSimulationRequest): SimulationResponse
    + getById(id: UUID): SimulationResponse
    + getMySimulations(pageable: Pageable): Page<SimulationResponse>
    + getPublicSimulations(pageable: Pageable): Page<SimulationResponse>
    + getFavorites(pageable: Pageable): Page<SimulationResponse>
    + update(id: UUID, request: UpdateSimulationRequest): SimulationResponse
    + delete(id: UUID): void
    + toggleFavorite(id: UUID): SimulationResponse
    + clone(id: UUID): SimulationResponse
    + share(id: UUID): SimulationResponse
    + generateReport(id: UUID, format: String): byte[]
}

class CalculationService <<Service>> {
    --
    + calculateResults(simulation: Simulation): SimulationResult
    - calculateMaxDeflection(params: SimulationParams): Double
    - calculateMaxBendingMoment(params: SimulationParams): Double
    - calculateMaxShearForce(params: SimulationParams): Double
    - calculateMaxStress(params: SimulationParams): Double
    - calculateSafetyFactor(stress: Double, material: MaterialType): Double
    - generateRecommendations(result: SimulationResult): List<String>
}

class FriendshipService <<Service>> {
    - friendshipRepository: FriendshipRepository
    - userRepository: UserRepository
    - notificationService: NotificationService
    --
    + getFriends(): List<FriendResponse>
    + getPendingRequests(): List<FriendResponse>
    + getSentRequests(): List<FriendResponse>
    + sendRequest(userId: UUID): FriendResponse
    + acceptRequest(friendshipId: UUID): FriendResponse
    + rejectRequest(friendshipId: UUID): void
    + removeFriend(friendshipId: UUID): void
}

class InvitationService <<Service>> {
    - invitationRepository: InvitationRepository
    - userRepository: UserRepository
    - emailService: EmailService
    --
    + getSentInvitations(): List<InvitationResponse>
    + getReceivedInvitations(): List<InvitationResponse>
    + sendInvitation(request: SendInvitationRequest): InvitationResponse
    + acceptInvitation(id: UUID): InvitationResponse
    + declineInvitation(id: UUID): void
    + cancelInvitation(id: UUID): void
}

class SharedSimulationService <<Service>> {
    - sharedSimulationRepository: SharedSimulationRepository
    - simulationRepository: SimulationRepository
    - notificationService: NotificationService
    --
    + getSharedWithMe(pageable: Pageable): Page<SharedSimulationResponse>
    + share(request: ShareSimulationRequest): SharedSimulationResponse
    + unshare(id: UUID): void
}

class NotificationService <<Service>> {
    - notificationRepository: NotificationRepository
    - messagingTemplate: SimpMessagingTemplate
    --
    + getNotifications(pageable: Pageable): Page<NotificationResponse>
    + getUnreadNotifications(pageable: Pageable): Page<NotificationResponse>
    + getUnreadCount(): Long
    + markAsRead(id: UUID): NotificationResponse
    + markAllAsRead(): Integer
    + delete(id: UUID): void
    + clearAll(): void
    + createAndSend(userId: UUID, type: NotificationType, title: String, message: String): void
}

class ChatService <<Service>> {
    - conversationRepository: ConversationRepository
    - messageRepository: ChatMessageRepository
    - messagingTemplate: SimpMessagingTemplate
    --
    + getConversations(): List<ConversationResponse>
    + getMessages(conversationId: UUID, pageable: Pageable): Page<ChatMessageResponse>
    + getUnreadCount(): Long
    + startConversation(userId: UUID): ConversationResponse
    + sendMessage(conversationId: UUID, request: SendMessageRequest): ChatMessageResponse
    + markAsRead(conversationId: UUID): Integer
    + deleteConversation(conversationId: UUID): void
}

class JwtService <<Service>> {
    - secretKey: String
    - accessTokenExpiration: Long
    --
    + generateAccessToken(user: User): String
    + generateRefreshToken(): String
    + validateToken(token: String): Boolean
    + extractUserId(token: String): UUID
    + extractEmail(token: String): String
    + extractRole(token: String): String
}

class EmailService <<Service>> {
    - mailSender: JavaMailSender
    --
    + sendInvitationEmail(to: String, senderName: String, message: String): void
    + sendPasswordResetEmail(to: String, resetToken: String): void
    + sendWelcomeEmail(to: String, name: String): void
}

class ReportService <<Service>> {
    --
    + generatePdfReport(simulation: Simulation, result: SimulationResult): byte[]
    + generateExcelReport(simulation: Simulation, result: SimulationResult): byte[]
}

' ==================== CONTROLLERS ====================

class AuthController <<Controller>> {
    - authService: AuthService
    --
    POST /api/v1/auth/register
    POST /api/v1/auth/login
    POST /api/v1/auth/refresh
    POST /api/v1/auth/logout
    POST /api/v1/auth/forgot-password
    POST /api/v1/auth/reset-password
}

class UserController <<Controller>> {
    - userService: UserService
    --
    GET /api/v1/users/me
    PUT /api/v1/users/me
    PUT /api/v1/users/me/password
    DELETE /api/v1/users/me
    GET /api/v1/users/me/stats
}

class SimulationController <<Controller>> {
    - simulationService: SimulationService
    --
    POST /api/v1/simulations
    GET /api/v1/simulations
    GET /api/v1/simulations/{id}
    PUT /api/v1/simulations/{id}
    DELETE /api/v1/simulations/{id}
    POST /api/v1/simulations/{id}/favorite
    GET /api/v1/simulations/favorites
    GET /api/v1/simulations/public
    POST /api/v1/simulations/{id}/clone
    GET /api/v1/simulations/{id}/report
    POST /api/v1/simulations/{id}/share
}

class FriendshipController <<Controller>> {
    - friendshipService: FriendshipService
    --
    GET /api/v1/friends
    GET /api/v1/friends/requests/pending
    GET /api/v1/friends/requests/sent
    POST /api/v1/friends/request/{userId}
    PUT /api/v1/friends/{friendshipId}/accept
    DELETE /api/v1/friends/{friendshipId}/reject
    DELETE /api/v1/friends/{friendshipId}
}

class InvitationController <<Controller>> {
    - invitationService: InvitationService
    --
    GET /api/v1/invitations/sent
    GET /api/v1/invitations/received
    POST /api/v1/invitations
    PUT /api/v1/invitations/{id}/accept
    PUT /api/v1/invitations/{id}/decline
    DELETE /api/v1/invitations/{id}
}

class SharedSimulationController <<Controller>> {
    - sharedSimulationService: SharedSimulationService
    --
    GET /api/v1/shared-simulations/with-me
    POST /api/v1/shared-simulations
    DELETE /api/v1/shared-simulations/{id}
}

class NotificationController <<Controller>> {
    - notificationService: NotificationService
    --
    GET /api/v1/notifications
    GET /api/v1/notifications/unread
    GET /api/v1/notifications/count
    PUT /api/v1/notifications/{id}/read
    PUT /api/v1/notifications/read-all
    DELETE /api/v1/notifications/{id}
    DELETE /api/v1/notifications
}

class ChatController <<Controller>> {
    - chatService: ChatService
    --
    GET /api/v1/chat/conversations
    GET /api/v1/chat/conversations/{id}/messages
    GET /api/v1/chat/unread-count
    POST /api/v1/chat/conversations/{userId}
    POST /api/v1/chat/conversations/{id}/messages
    PUT /api/v1/chat/conversations/{id}/read
    DELETE /api/v1/chat/conversations/{id}
}

class WebSocketController <<Controller>> {
    - chatService: ChatService
    --
    @MessageMapping /chat.send
    @SendTo /topic/chat/{conversationId}
}

' ==================== RELATIONSHIPS ====================

' Entity Relationships
User "1" -- "*" Simulation : owns >
User "1" -- "*" Notification : receives >
User "1" -- "*" RefreshToken : has >
User "*" -- "*" User : friends
User "1" -- "*" Invitation : sends >
Simulation "1" -- "0..1" SimulationResult : has >
Simulation "*" -- "*" User : shared with
Conversation "1" -- "*" ChatMessage : contains >
User "*" -- "*" User : converses

' Service Dependencies
AuthService --> UserRepository
AuthService --> RefreshTokenRepository
AuthService --> JwtService

UserService --> UserRepository
UserService --> SimulationRepository

SimulationService --> SimulationRepository
SimulationService --> SimulationResultRepository
SimulationService --> CalculationService
SimulationService --> ReportService

FriendshipService --> FriendshipRepository
FriendshipService --> UserRepository
FriendshipService --> NotificationService

InvitationService --> InvitationRepository
InvitationService --> UserRepository
InvitationService --> EmailService

SharedSimulationService --> SharedSimulationRepository
SharedSimulationService --> SimulationRepository
SharedSimulationService --> NotificationService

NotificationService --> NotificationRepository

ChatService --> ConversationRepository
ChatService --> ChatMessageRepository

' Controller Dependencies
AuthController --> AuthService
UserController --> UserService
SimulationController --> SimulationService
FriendshipController --> FriendshipService
InvitationController --> InvitationService
SharedSimulationController --> SharedSimulationService
NotificationController --> NotificationService
ChatController --> ChatService
WebSocketController --> ChatService

@enduml
